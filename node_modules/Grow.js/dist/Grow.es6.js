var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var Thing = require('Thing.js');
var _ = require('underscore');
var assert = require('assert');
var util = require('util');
var Duplex = require('stream').Duplex;
var RSVP = require('rsvp');
var later = require('meteor-later');
var DDPClient = require('ddp');
var EJSON = require('ddp-ejson');
var Readable = require('stream').Readable;
var Writable = require('stream').Writable;
var fs = require('fs');
var stringify = require('json-stringify-safe');

/**
 * Class representing a new grow instance: connects to the Grow-IoT server specified in the config (default localhost:3000), registers the device with the Server (if it's the first time connecting it saves a new uuid and token), and sets up readable and writable streams.
 * @param {Object} config  The thing configuration object.
 * @param {Function} callback  An optional callback.
 * @return     A new grow instance.
 */

var Grow = function Grow(config, callback) {
  var _this = this;

  classCallCheck(this, Grow);

  // Use local time.
  later.date.localTime();

  // TODO: this needs to be rewritten...
  try {
    // HACK: there must be a better way to require state.json
    // This is for when Grow.js is in the node_modules folder.
    var state = require('../../.././state.json');
    console.log('Loading from state.json');
    _.extend(this, state);
  } catch (err) {
    try {
      // When developing...
      var state = require('.././state.json');
      console.log('Loading from state.json');
      _.extend(this, state);
    } catch (err) {
      this.uuid = null;
      this.token = null;
    }
  }

  this.thing = new Thing(config);

  Duplex.call(this, _.defaults(config, { objectMode: true, readableObjectMode: true, writableObjectMode: true }));

  this._messageHandlerInstalled = false;

  this.ddpclient = new DDPClient(_.defaults(config, {
    host: 'localhost',
    port: 3000,
    ssl: false,
    maintainCollections: false
  }));

  this.afterConnect = function (callback, result) {
    _this.ddpclient.subscribe('Device.messages', [{ uuid: _this.uuid, token: _this.token }], function (error) {
      if (error) return console.log(error);

      if (!_this._messageHandlerInstalled) {
        _this._messageHandlerInstalled = true;

        _this.ddpclient.on('message', function (data) {
          data = EJSON.parse(data);

          if (data.msg !== 'added' || data.collection !== 'Device.messages') {
            return;
          }

          _this.push(data.fields.body);
        });
      }
    });

    // Now check to see if we have a stored UUID.
    // If no UUID is specified, store a new UUID.
    if (!_.isUndefined(_this.uuid) && !_.isUndefined(_this.token)) {
      _this.writeChangesToState();
    }

    // SETUP STREAMS
    // Readable Stream: this is 'readable' from the server perspective.
    // The device publishes it's data to the readable stream.
    _this.readableStream = new Readable({ objectMode: true });

    // We are pushing data when sensor measures it so we do not do anything
    // when we get a request for more data. We just ignore it for now.
    _this.readableStream._read = function () {};

    // We are pushing data to a stream as commands are arriving and are leaving
    // to the stream to buffer them. So we simply ignore requests for more data.
    _this._read = function (size) {};

    _this.readableStream.on('error', function (error) {
      console.log('Error', error.message);
    });

    // Writable stream: this is writable from the server perspective. A device listens on
    // the writable stream to recieve new commands.
    _this.writableStream = new Writable({ objectMode: true });

    // Sets up listening for actions on the writeable stream. Note: writable from
    // the server's perspective.
    _this.writableStream._write = function (command, encoding, callback) {
      if (command.type === 'updateActionSchedule') {
        _this.updateActionProperty(command.options.actionKey, 'schedule', command.options.newValue);
      } else if (command.options) {
        _this.thing.callAction(command.type, command.options);
      } else {
        _this.thing.callAction(command.type);
      }

      callback(null);
    };

    // On _write, call API.sendData()
    _this._write = function (chunk, encoding, callback) {
      _this.sendData(chunk, callback);
    };

    // Pipe things.
    _this.pipe(_this.writableStream);
    _this.readableStream.pipe(_this);
  };

  this.ddpclient.connect(function (error, wasReconnect) {
    if (error) return callback(error);

    if (wasReconnect) {
      console.log('Reestablishment of a Grow server connection.');
    } else {
      console.log('Grow server connection established.');
    }

    if (_this.uuid || _this.token) {
      return _this.afterConnect(callback, {
        uuid: _this.uuid,
        token: _this.token
      });
    }

    _this.ddpclient.call('Device.register', [config], function (error, result) {
      if (error) {
        if (!_.isUndefined(callback)) {
          return callback(error);
        } else {
          console.log(error);
        }
      }

      assert(result.uuid, result);
      assert(result.token, result);

      _this.uuid = result.uuid;
      _this.token = result.token;

      _this.afterConnect(callback, result);
    });
  });

  /**
   * Writes current state to state.json.
   */
  this.writeChangesToState = function () {
    fs.writeFile('./state.json', stringify(_this, null, 4), function (error) {
      if (error) return console.log('Error', error);
    });
  };

  /**
   * Send data to Grow-IoT server.
   * @param {Object} data  Data to log on the server
   * @param {Function} callback  Optional callback
   */
  this.sendData = function (data, callback) {
    if (!_this.ddpclient || !_this.uuid || !_this.token) {
      callback('Invalid connection state.');
      return;
    }

    _this.ddpclient.call('Device.sendData', [{ uuid: _this.uuid, token: _this.token }, data], function (error, result) {
      if (error) console.log(error);

      if (!_.isUndefined(callback)) {
        callback(null, result);
      }
    });
  };

  /**
   * Emit device event to Grow-IoT server.
   * @param {Object}  event  The event to emit
   * @param {Function} callback  Optional callback
   */
  this.emitEvent = function (eventMessage, callback) {
    var body = {
      'message': eventMessage
    };
    body.timestamp = new Date();

    _this.ddpclient.call('Device.emitEvent', [{ uuid: _this.uuid, token: _this.token }, body], function (error, result) {
      if (!_.isUndefined(callback)) {
        callback(error, result);
      }
    });
  };

  /**
   * Calls thing.callAction and emits an event to Grow-IoT.
   * @param {String} actionKey  key of the action you want to call.
   * @param {Object|List|String|Number|Boolean} options The new value to set the property to.
   */
  this.callAction = function (actionKey, options) {
    var action = _this.thing.getAction(actionKey);
    _this.thing.callAction(actionKey, options);

    // Check to see if action has an event message
    if (!_.isUndefined(action.event)) {
      _this.emitEvent(action.event);
    } else {
      _this.emitEvent(actionKey);
    }
  };

  /**
   * Update an action property such as schedule or action options.
   * @param {String} actionKey  key of the action you want to update.
   * @param {String} property  the property you want to set.
   * @param {Object|List|String|Number|Boolean} value  the new property value.
   */
  this.updateActionProperty = function (actionKey, property, value) {
    var action = _this.thing.getAction(actionKey);
    action[property] = value;

    // If the property being updated is the schedule property, restart the scheduled action.
    if (property === 'schedule') {
      _this.thing.scheduledActions[actionKey].clear();
      _this.thing.startAction(actionKey);
    }

    _this.ddpclient.call('Device.updateActionProperty', [{ uuid: _this.uuid, token: _this.token }, actionKey, property, value], function (error, result) {
      if (error) {
        console.log(error);
      }
    });
  };

  /**
   * Update an event property such as schedule or options.
   * @param {String} eventKey  key of the event you want to update.
   * @param {String} property  the property you want to set.
   * @param {Object|List|String|Number|Boolean} value  the new property value.
   */
  this.updateEventProperty = function (eventKey, property, value) {
    var event = _this.thing.getEvent(eventKey);
    event[property] = value;

    // If the property being updated is the schedule property, restart the scheduled action.
    if (property === 'schedule') {
      _this.thing.scheduledEvents[eventKey].clear();
      _this.thing.startEvent(eventKey);
    }

    _this.ddpclient.call('Device.updateEventProperty', [{ uuid: _this.uuid, token: _this.token }, eventKey, property, value], function (error, result) {
      if (error) {
        console.log(error);
      }
    });
  };

  /**
   * Update device property on Grow-IoT server.
   * @param {String} property  Name of the of the property you wish to update
   * @param {Object|List|String|Number|Boolean} value The new value to set the property to.
   * @param {Function} callback  An optional callback.
   */
  this.setProperty = function (property, value, callback) {
    // Update the thing property.
    _this.thing.setProperty(property, value);

    // Not working in this version of Grow.js yet.
    _this.writeChangesToState();

    _this.ddpclient.call('Device.udpateProperty', [{ uuid: _this.uuid, token: _this.token }, property, value], function (error, result) {
      if (!_.isUndefined(callback)) {
        callback(error, result);
      }
    });
  };

  if (!_.isUndefined(callback)) {
    callback();
  }
};

;

util.inherits(Grow, Duplex);

export default Grow;
//# sourceMappingURL=Grow.es6.js.map